# Redis



------

[TOC]

### 什么是NoSQL?

NoSQL，泛指非关系型的数据库。随着互联网[web2.0](https://baike.baidu.com/item/web2.0/97695)网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的[SNS](https://baike.baidu.com/item/SNS/10242)类型的web2.0纯[动态网](https://baike.baidu.com/item/动态网)站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。

```
NoSql
- 不仅仅是数据
- 没有固定的查询语言
- 键值对存储、列存储、文档存储、图形数据库等等
- 最终一致性
- 高性能、高可用、高扩展
- 无强制schema, 方便快速上手

```

### Nosql四大分类

1. **KV键值对**:

   Redis

2. **文档型数据库(bson,和json一样)**

   MongoDB

3. **列式存储**

   Hbase

4. **Graph 图形数据库**



**优缺点对比:** 

![image-20220330220113128](/home/cby/snap/typora/57/.config/Typora/typora-user-images/image-20220330220113128.png)



### Redis概述

- Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI [C语言](https://baike.baidu.com/item/C语言)编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库](https://baike.baidu.com/item/数据库/103728)，并提供多种语言的API.
- redis是一个key-value[存储系统](https://baike.baidu.com/item/存储系统)。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list([链表](https://baike.baidu.com/item/链表))、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些[数据类型](https://baike.baidu.com/item/数据类型)都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步.
- Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了[memcached](https://baike.baidu.com/item/memcached)这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便

中文文档: http://www.redis.cn/commands.html

#### Redis 能做什么

1. 内存存储, 持久化 -- RDB、AOF
2. 效率高，基于内存实现数据访问，可以用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器

   ......

#### 特性

- 多样的数据类型

- 持久化

- 集群

- 事物

   ......

### 性能测试工具

自带性能测试工具 - redis benchmark 

`docker启动redis`

```
redis:
  image: redis:alpine3.13
  container_name: docker_redis
  deploy:
    resources:
      limits:
        cpus: "0.50"
        memory: 4G
      reservations:
        cpus: "0.25"
        memory: 1G
  volumes:
    - /home/${USER}/redis/data:/data
  ports:
    - 6379:6379
```

进入容器:执行 `redis-benchmark  -c 10000  -n 1000 -t get`  并发量10000,执行1000次

![](/home/cby/Pictures/Screenshot from 2022-03-31 20-46-42.png)

结果:总耗时18毫秒



### 5大基本数据类型

- String
- List
- Set
- HashMap
- Zset - 有序集合

### 三种特殊类型

- Geospatial 地理位置(经度/纬度)
  - 附近的人
  - 两点间距离

- Hyperloglog 基数统计
  - UV/PV统计
  - 允许容错,0.81%的错误率
  
- Bitmap 位存储

  - 打卡统计
  - 节省内存
  - 适用于只有两种状态的数据

  

### 事务操作

- Redis 事务的`本质是一组命令的集合`。事务支持一次执行多个命令，一个事务中所有命令都会被[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

  > 总结说：`redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令`

- Redis事物没有隔离级别: 批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到.

- Redis不保证原子性: Redis中，单条命令是原子性执行的，**但`事务不保证原子性，且没有回滚`.事务中任意命令执行失败，其余的命令仍会被执行**.

### 悲观所和乐观锁

1. 悲观锁

   做任何操作之前，先对数据加锁

2. 乐观锁: watch 监听数据的变动

   > 也可理解为版本号比较机制，主要是说在读取数据逇时候同时读取其版本号，然后在写入的时候，进行版本号比较，如果一致，则表明此数据在监听期间未被改变，可以写入，如果不一致说明此数据被修改过，不能写入，否则会导致数据不一致的问题

### Jedis 和 Lettuce

- jedis和Lettuce都是Redis的客户端，它们都可以连接Redis服务器，但是在SpringBoot2.0之后默认都是使用的Lettuce这个客户端连接Redis服务器。因为当使用Jedis客户端连接Redis服务器的时候，每个线程都要拿自己创建的Jedis实例去连接Redis客户端，当有很多个线程的时候，不仅开销大需要反复的创建关闭一个Jedis连接，而且也是线程不安全的，一个线程通过Jedis实例更改Redis服务器中的数据之后会影响另一个线程.
- 但是如果使用Lettuce这个客户端连接Redis服务器的时候，就不会出现上面的情况，Lettuce底层使用的是Netty，当有多个线程都需要连接Redis服务器的时候，可以保证只创建一个Lettuce连接，使所有的线程共享这一个Lettuce连接，这样可以减少创建关闭一个Lettuce连接时候的开销；而且这种方式也是线程安全的，不会出现一个线程通过Lettuce更改Redis服务器中的数据之后而影响另一个线程的情况.

### 配置文件

- 网络
- 日志
- 数据库
- 持久化 
  - rdb 
  - aof
- 副本
- 密码
- 客户端连接数
- 最大内存设置
- maxmemory-policy: 内存满后的拒绝策略

```
1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 
2、allkeys-lru ： 删除lru算法的key   
3、volatile-random：随机删除即将过期key   
4、allkeys-random：随机删除   
5、volatile-ttl ： 删除即将过期的   
6、noeviction ： 永不过期，返回错误
```

### Redis持久化

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。 在我们安装了redis之后，所有的配置都是在redis.conf文件中，里面保存了RDB和AOF两种持久化机制的各种配置。 当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘.

#### RDB

- 符合自定义配置的快照规则（redis.conf）

> save：这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如"save m n"。表示m秒内数据集存在n次修改时，自动触发bgsave。
>
> 默认如下配置： save 900 1 ：表示900秒钟内至少1个键被更改则进行快照。 save 300 10 ：表示300秒内至少10个键被更改则进行快照。 save 60 10000 ：表示60秒内至少10000个键被更改则进行快照。
>
> 如果不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能或设置为save "" 

- 执行save或者bgsave命令

> save: 执行该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止

> bgsave: 具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令

优点: 

1. 适合大规模数据恢复
2. 对数据的完整性要

缺点:

1. fork 进程需要一定的内存空间
2. 需要一定的时间间隔进行进程操作，如果意外宕机，最后一次未持久化操作的数据将会丢失

#### AOF(append only)

AOF (Append Only File)  持久化默认是关闭的，通过将 redis.conf 中将 appendonly no，修改为 appendonly yes 来开启AOF 持久化功能，如果服务器开始了 AOF 持久化功能，服务器会优先使用 AOF 文件来还原数据库状态, 每当 Redis 接受到会修改数据集的命令时，就会把**命令**追加到 AOF 文件里，当你重启 Redis 时，AOF 文件里的命令会被重新执行一次，重建数据.

Redis提供了aof文件修复工具

AOF重写: 首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理

优点:

1. 每一次修改都同步,文件会更加完整
2. 默认每秒同步一次

缺点: 

1. 性能低,长时间运行会导致备份文件过于庞大

### Redis发布订阅

> redis可以简单的实现发布订阅功能

### Redis主从复制

slave命令: SLAVEOF host port

配置文件中配置

#### 作用

- 数据冗余，实现数据的热备份，这也是持久化实现的另一种方式。
- 针对单机故障问题，一个节点故障，其他节点可以提供服务，不影响用户使用。实现了快速恢复故障，这也是服务冗余。

- **读写分离，master服务主要用来写，slave服务主要用来读数据**。可以提高服务器的负载能力，可以根据需求的变化，添加从节点的数量。
- 负载均衡，同时配合读写分离，由主节点提供写服务，从节点提供读服务，分担服务器的负载。在写少读多的情况下，通过多个从节点分担读负载，能够大大提高Redis服务的并发量和负载。

- 高可用的基石，主从复制是哨兵和集群模式能够实施的基础。

#### 主从复制的三个阶段

- 建立连接过程：这个是slave跟master建立连接的过程
- 数据同步的过程：是maser同步数据给slave的过程
- 命令传播过程：是反复同步数据的过程

补图: TBD

#### 全量复制和增量复制

- 当slave第一次连接到master时，会发送sync指令，这个时候master会把所有数据发送到slave,此为全量复制
- master继续将修改命令依次传给slave,完成同步，此为增量复制

#### 层层链路模型

A(master):arrow_right:B(master&slave):arrow_right:C(slave)

#### 哨兵模式

主从切换技术：当主机宕机后，需要手动把一台从（slave）服务器切换为主服务器，这就需要人工干预，费时费力，还回造成一段时间内服务不可用，所以推荐哨兵架构（Sentinel）来解决这个问题。
哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

![image-20220404214147479](/home/cby/snap/typora/57/.config/Typora/typora-user-images/image-20220404214147479.png)

作用

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器
- 当哨兵监测到Redis主机宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他服务器，修改配置文件，让他们换主机

一般都会配置多哨兵(即哨兵集群)

优点：

1.哨兵集群，基于主从复制模式，所有的主从配置优点，它全有

2.主从可以切换，故障可以转移，系统的可用性就会更好

3.哨兵模式就是主从模式的升级，手动到自动，更加健壮！

缺点：

1.Redis不好在线扩若的，集群容量一旦到达上限，在线扩容十分麻烦！

2.实现哨兵模式的配置其实是很麻烦的，里面有很多选择。



### 缓存穿透、击穿和雪崩

#### 缓存穿透

缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于 是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是 都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

- 布隆过滤器
  - 布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则 丢弃，从而避免了对底层存储系统的查询压力；
- 缓存空对象
  - 当缓存层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；

#### 缓存击穿

就比如说：微博又有明星出轨了，大量用户请求去请求同一个东西，这个时候缓存某个key设置的过期时间是60s，60.1s缓存恢复了，在这0.1s的时间内，大量的请求就跑到了MySQL关系型数据库里面了，容易使数据库宕机，这就是击穿！

这里需要注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中 对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一 个屏障上凿开了一个洞.

当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访 问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

解决方案

- 设置热点数据永不过期(一般不建议用,会撑爆服务器内存)

- 加互斥锁

  > 使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大！

  如下图：当大量请求在key过期后的很短时间内跑到了MySQL数据库，我们采用分布式锁，保证只有一个线程跑到MySQL数据库！对分布式锁考验很大！

  ![image-20220404224757318](/home/cby/snap/typora/57/.config/Typora/typora-user-images/image-20220404224757318.png)

#### 缓存雪崩

> 缓存雪崩，是指在某一个时间段，缓存集中过期失效。（比如说停电了，Redis宕机！）
>
> 产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况

### Redis高可用方案

- 设几台redis，这样一台挂掉之后其他的还可以继续 工作，其实就是搭建的集群(还可以增加异地多活)

- 限流降级

  > 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对 某个key只允许一个线程查询数据和写缓存，其他线程等待

- 数据预热

  数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数 据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，**设置不同的过期时间，让缓存失效的时间点尽量均匀**